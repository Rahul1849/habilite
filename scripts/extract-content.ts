/**
 * Extracts static text and image URLs from project TSX/JSX/TS/JS files.
 * Outputs to scripts/content/raw-extracted.ts
 *
 * Run (after installing dev deps): npm install
 * Then: npx ts-node scripts/extract-content.ts
 */

import fs from "fs-extra";
import path from "path";
import { globSync } from "glob";
import { parse } from "@babel/parser";
import traverseModule from "@babel/traverse";

const ROOT = process.cwd();
const INPUT_DIRS = ["app", "components", "pages"];
const OUTPUT_FILE = path.join(ROOT, "scripts", "content", "raw-extracted.cjs");
const SITE_BASE = "https://www.habiliteclinics.com";

function toAbsolute(src?: string | null) {
  if (!src) return null;
  if (/^https?:\/\//i.test(src)) return src;
  if (src.startsWith("//")) return `https:${src}`;
  if (src.startsWith("/")) return `${SITE_BASE}${src}`;
  return null;
}

type Extracted = {
  file: string;
  texts: string[];
  images: string[];
};

function extractFromFile(filePath: string): Extracted | null {
  const code = fs.readFileSync(filePath, "utf8");
  let ast;
  try {
    ast = parse(code, {
      sourceType: "module",
      plugins: ["typescript", "jsx"],
    });
  } catch (err) {
    console.warn(`⚠️  Parse skipped: ${filePath} (${(err as Error).message})`);
    return null;
  }

  const texts = new Set<string>();
  const images = new Set<string>();

  const traverse: any = (traverseModule as any).default || traverseModule;

  traverse(ast, {
    JSXText(path: any) {
      const value = path.node.value.replace(/\s+/g, " ").trim();
      if (value) texts.add(value);
    },
    StringLiteral(path: any) {
      const val = path.node.value.replace(/\s+/g, " ").trim();
      if (!val) return;

      const parent: any = path.parentPath?.node;
      // If this is an attribute like src/href/alt/title/text
      if (
        parent &&
        parent.type === "JSXAttribute" &&
        parent.name &&
        typeof (parent.name as any).name === "string"
      ) {
        const name = (parent.name as any).name;
        if (["src", "href", "poster"].includes(name)) {
          const abs = toAbsolute(val);
          if (abs) images.add(abs);
          return;
        }
        if (["alt", "title", "aria-label", "content", "text"].includes(name)) {
          texts.add(val);
          return;
        }
      }

      // Otherwise, collect as generic text
      texts.add(val);
    },
    JSXAttribute(path: any) {
      const name = (path.node.name as any)?.name;
      const value = path.node.value;
      if (!name || !value) return;
      if (value.type === "StringLiteral") {
        if (["src", "href", "poster"].includes(name)) {
          const abs = toAbsolute(value.value);
          if (abs) images.add(abs);
        } else if (["alt", "title", "aria-label", "content", "text"].includes(name)) {
          const t = value.value.replace(/\s+/g, " ").trim();
          if (t) texts.add(t);
        }
      }
    },
  });

  return {
    file: path.relative(ROOT, filePath),
    texts: Array.from(texts),
    images: Array.from(images),
  };
}

async function main() {
  const patterns = INPUT_DIRS.map((dir) =>
    path.join(ROOT, dir, "**", "*.{ts,tsx,js,jsx}").replace(/\\/g, "/")
  );

  const files = patterns.flatMap((pattern) =>
    globSync(pattern, {
      ignore: ["**/node_modules/**", "**/.next/**", "**/sanity/**"],
    })
  );

  const results: Extracted[] = [];
  let parseFailures = 0;

  for (const file of files) {
    const data = extractFromFile(file);
    if (!data) {
      parseFailures += 1;
      continue;
    }
    if (data.texts.length || data.images.length) results.push(data);
  }

  // Ensure output dir
  fs.ensureDirSync(path.dirname(OUTPUT_FILE));

const content = `// Auto-generated by scripts/extract-content.ts
exports.extractedContent = ${JSON.stringify(results, null, 2)};
`;

  fs.writeFileSync(OUTPUT_FILE, content, "utf8");
  console.log(
    `✅ Extracted ${results.length} files (of ${files.length} scanned, ${parseFailures} parse failures) to ${path.relative(
      ROOT,
      OUTPUT_FILE
    )}`
  );
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});

